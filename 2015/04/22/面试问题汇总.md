# HTTP和HTTPS

### HTTPS和HTTP的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



### HTTP和HTTPS的基本概念：

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。



### HTTP特点：

1.支持客户/服务器模式。（C/S模式）

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快

HTTP工作流程

第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接

第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）

第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕

第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK

第五步：服务器向客户端发送应答头信息

第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端

第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

### HTTPS特点：

HTTPS是HTTP协议的修改，它加密数据并确保其机密性。其配置可保护用户在与网站交互时免于窃取个人信息和计费数据。

1、优点

相比于http，https可以提供更加优质保密的信息，保证了用户数据的安全性，此外https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。

2、缺点

缺点也同样很明显，第一https的技术门槛较高，多数个人或者私人网站难以支撑，CA机构颁发的证书都是需要年费的，此外对接Https协议也需要额外的技术支持；其二，目前来说大多数网站并不关心数据的安全性和保密性，其https最大的优点对它来说并不适用；其三，https加重了服务端的负担，相比于http其需要更多的资源来支撑，同时也降低了用户的访问速度；第四，目前来说Http网站仍然大规模使用，在浏览器侧也没有特别大的差别，很多用户不关心的话根本不感知。



### HTTPS工作流程：

第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

第五步：Web服务器利用自己的私钥解密出会话密钥。

第六步：Web服务器利用会话密钥加密与客户端之间的通信。

最后说一句 ，ssl证书阿里云上可以免费申请一年



### 一、什么是爬虫

网络爬虫（又被称为网页蜘蛛，网络机器人），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。我们可以使用爬虫自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。但是需要注意，爬虫不会创造数据，也不会生产数据。他只能爬取网络上输出的信息。

目前很多语言都支持爬虫，除了我们这里介绍`Python`爬虫，还有`php`，`javascript`,`java`,`php`，`go`等等都可以实现爬虫，但是`Python`爬虫因为使用发布而且有很多好用的拓展包，让`python`爬虫非常有效而且受欢迎。

### 二、爬虫的作用

在我们浏览网页,浏览器会渲染输出`HTML`、`JS`、`CSS`等信息；通过这些元素，我们就可以看到我们想要查看的新闻,图片,电影,评论,商品等等。一般情况下我们看到自己需要的内容，图片可能会复制文字并且下载图片保存，但是如果面对大量的文字和图片，我们人工是处理不过来的，同时比如类似百度需要每天定时获取大量网站最新文章并且收录，这些大量数据与每天的定时的工作我们是无法通过人工去处理的，这时候爬虫的作用就体现出来了。

### 三、爬虫抓取的对象

爬虫可以抓取网页信息,APP以及客户端信息；我们可以访问保存新闻,图片,电影,评论,商品等等。理论上来说,只要我们可以访问到的数据，我们就能通过爬虫抓取到，同时如果你了解编程基础，你也可以抓取到你在网页中看不到的数据。

 





## 几种常见的非关系型数据库

#### HBase

列式存储以流的方式在列中存储所有的数据。对于任何记录，索引都可以快速地获取列上的数据；列式存储支持行检索，但这需要从每个列获取匹配的列值，并重新组成行。HBase（Hadoop Database）是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。HBase是Google BigTable的开源实现，模仿并提供了基于Google文件系统的BigTable数据库的所有功能。HBase可以直接使用本地文件系统或者Hadoop作为数据存储方式，不过为了提高数据可靠性和系统的健壮性，发挥HBase处理大数据量等功能，需要使用Hadoop作为文件系统。HBase仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务，主要用来存储非结构化和半结构化的松散数据。

##### Hbase中表的特点：大，稀疏，面向列

Hadoop生态系统中的各层系统

HBase位于结构化存储层；

HDFS为HBase提供了高可靠性的底层存储支持；

MapReduce为HBase提供了高性能的计算能力；

Zookeeper为HBase提供了稳定服务和失败恢复机制；

Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单；

Sqoop则为HBase提供了方便的RDBMS数据导入功能，方便数据迁移；

Hbase在互联网存储的几个应用场景：

1.抓取增量数据

使用HBase 作为数据存储，抓取来自各种数据源的增量数据，如抓取用户交互数据，以备之后进行分析、处理

2.内容服务

传统数据库最主要的使用场合之一是为用户提供内容服务，如URL短链接服务，可以HBase为基础，存储大量的短链接以及和原始长链接的映射关系

3.信息交换

Facebook的短信平台每天交换数十亿条短信，HBase可以很好的满足该平台的需求：高的写吞吐量，极大的表，数据中心的强一致性

Hbase与传统关系型数据库区别：

数据类型

HBase只有简单的字符串类型，所有类型都由用户自己处理，它只保存字符串；

关系数据库有丰富的类型选择和存储方式。

数据操作

HBase操作只有很简单的插入、查询、删除、清空等，表和表之间是分离的，没有复杂的表和表之间的关系，所以也不能也没有必要实现表和表之间的关联等操作；

传统的关系数据通常有各种各样的函数、连接操作。

存储模式

HBase是基于列存储的，每个列族都有几个文件保存，不同列族的文件是分离的；

传统的关系数据库是基于表格结构和行模式保存的。

数据维护

HBase的更新正确来说应该不叫更新，而且一个主键或者列对应的新的版本，而它旧有的版本仍然会保留，所以它实际上是插入了新的数据；

传统关系数据库里面是替换修改。

可伸缩性

HBase和BigTable这类分布式数据库就是直接为了这个目的开发出来的，能够轻易的增加或者减少（在硬件错误的时候）硬件数量，而且对错误的兼容性比较高；

传统的关系数据库通常需要增加中间层才能实现类似的功能。

修改表模式需要先将表设置为不可用(disable)，模式修改完成再启用表(enable)

HBase的三个主要的功能组件

库函数：链接到每个客户端；一个HMaster主服务器；许多个HRegion服务器。

Hbase三层结构

1.Zookeeper文件：它记录了-ROOT-表的位置信息，即root region的位置信息。

2.-ROOT-表：只包含一个root region，记录了.META.表中的region信息。通过root region，我们就可以访问.META.表的数据。

3.META.表：记录了用户表的HRegion信息，.META.表可以有多个HRegion，保存了HBase中所有数据表的HRegion位置信息。

Hbase两种文件类型

HFile：HBase中KeyValue数据的存储格式，HFile是Hadoop的二进制格式文件，实际上HStoreFile就是对HFile做了轻量级包装，即HStoreFile底层就是HFile。

HLogFile：HBase中WAL（Write Ahead Log）的存储格式，物理上是Hadoop的顺序文件。





### Redis

    Redis是一个key-value存储系统,key为字符串类型，只能通过key对value进行操作，支持的数据类型包括string、list、set、zset(有序集合)和hash。Redis支持主从同步，数据可以从主服务器向任意数量的从服务器上同步。

    Redis事务允许一组命令在单一步骤中执行。事务有两个属性：在一个事务中的所有命令作为单个独立的操作顺序执行；Redis事务是原子的，原子意味着要么所有的命令都执行，要么都不执行。Redis 事务由指令 MULTI 发起的，之后传递需要在事务中和整个事务中，最后由 EXEC 命令执行所有命令的列表。

Redis分区

    是将数据分割成多个 Redis 实例，使每个实例将只包含键子集的过程.它允许更大的数据库，使用多台计算机的内存总和,它允许按比例在多内核和多个计算机计算，以及网络带宽向多台计算机和网络适配器。劣势：涉及多个键时，Redis事务无法使用；数据处理比较复杂；加和删除的容量可能会很复杂。

分区类型：范围分区；散列分区

Redis 数据库可以配置安全保护的，所以任何客户端在连接执行命令时需要进行身份验证。

#### 应用：统计




MongodDB

    一个基于分布式文件存储的开源数据库系统，为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key value)对组成，数据存储为BSON（Binary JSON）格式，二进制的json。

特点：

    面向集合存储，易存储对象类型的数据；模式自由；支持动态查询；支持完全索引，包含内部对象；支持查询；支持复制和故障恢复；使用高效的二进制数据存储，包括大型对象（如视频）；自动处理碎片，以支持云计算层次的扩展性；支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言；文件存储格式为BSON（一种JSON的扩展）；可通过网络访问。

#### 适用场景：网站数据；缓存；大尺寸，低价值的数据；高伸缩性的场景；用于对象及JSON 数据的存储。

不适用场景：高度事务性的系统；传统的商业智能应用；需要SQL 的问题。

聚合管道将文档在一个管道处理完毕后将结果传递给下一个管道处理，管道操作是可以重复的。

引用式文档查询：需要两次查询

    第一次查询用户地址的对象id（ObjectId）；第二次通过查询的id获取用户的详细地址信息。

    集合中索引不能超过64个；索引名的长度不能超过125个字符；一个复合索引最多可以有31个字段。mongorestore 命令来恢复备份的数据。





### Neo4j 

    是一个高性能的 NoSQL 图形数据库，把数据保存为图中的节点以及节点之间的关系。Neo4j 中两个最基本的概念是节点和边

节点表示实体，边则表示实体之间的关系。节点和边都可以有自己的属性，不同实体通过各种不同的关系关联起来，形成复杂的对象图。

    Neo4j 提供了在对象图上进行查找和遍历的功能：深度搜索、广度搜索。

特点：

    完整的ACID支持；高可用性；轻易扩展到上亿级别的节点和关系；通过遍历工具高速检索数据；属性是由Key-Value键值对组成。

#### 应用：社交网络，歌曲信息，状态图











## IDE工具 

集成开发环境

python常见的：

​	pycharm

​	sublime Text

​	Atom

​	vscode

​	







### 浅拷贝和深拷贝

##### python里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）

在python中如何拷贝一个对象是需要根据具体的需求来定的。

（1）赋值：其实就是对象的引用。相当于C的指针，修改了其中一个对象，另一个跟着改变。注意对于不可变对象而言，如果修改了其中一个对象，就相当于修改它的指针指向，另一个对象是不会跟着变化的。

```
1 a = ['1', '2'] # a是一个可变对象
2 b = a
3 a = a.pop()
4 print(b) # 修改了a，b也跟着变
```

输出结果：

```
1 ['1']
```

当a为不可变对象时：

```
1 a = 1
2 b = a
3 a = 2
4 print('b = {}'.format(b))
```

输出结果：

```
1 b = 1
```

（2）浅拷贝：拷贝父对象，但是不会拷贝父对象的子对象。（具体的方法有：b = copy.copy(a)，切片如b = a[1:4]）

```
1 a = {1: [1, 2, 3]}
2 b = a.copy()
3 print(a, b)
4 a[1].append(4)
5 print(a, b)
```

输出结果为：

```
{1: [1, 2, 3]} {1: [1, 2, 3]}
{1: [1, 2, 3, 4]} {1: [1, 2, 3, 4]}
```

当a为不可变对象时：

```
1 import copy
2 a = 'TEST_STRING'
3 b = copy.copy(a)
4 print(a, b)
5 a = a.lower()
6 print(a, b)
```

输出结果：

```
1 TEST_STRING TEST_STRING
2 test_string TEST_STRING
```

（3）深拷贝：完全拷贝了父对象和子对象（具体的方法有：b = copy.deepcopy(a)）

```
1 import copy
2 a = {1: [1, 2, 3]}
3 b = copy.deepcopy(a)
4 print(a, b)
5 a[1].append(4)
6 print(a, b)
```

输出结果：

```
1 {1: [1, 2, 3]} {1: [1, 2, 3]}
2 {1: [1, 2, 3, 4]} {1: [1, 2, 3]}
```

当a为不可变对象时：

```
1 import copy
2 a = 'TEST_STRING'
3 b = copy.deepcopy(a)
4 print(a, b)
5 a = a.lower()
6 print(a, b)
```

输出结果：

```
1 TEST_STRING TEST_STRING
2 test_string TEST_STRING
```

总结：

（1）当对象为不可变类型时，不论是赋值，浅拷贝还是深拷贝，那么改变其中一个值时，另一个都是不会跟着变化的。

（2）当对象为可变对象时，如果是赋值和浅拷贝，那么改变其中任意一个值，那么另一个会跟着发生变化的；如果是深拷贝，是不会跟着发生改变的。





### 如果custname字符串的编码格式为uft-8,如何将custname的内容转化为gb18030的字符串？

先将custname编码格式转换为unicode，在转换为gb18030。即custname.decode('utf-8').encode('gb18030')。

注意：unicode编码是一种二进制编码，是转换编码的中间桥梁。比如需要将utf-8转换为gbk，那么就需要先转换为unicode（decode），再转为gbk（encode）。





##### 请写出一段python代码实现删除list中的重复元素。

两种方法：

（1）利用字典的fromkeys来自动过滤重复值

（2）利用集合set的特性，元素是非重复的

方法一：

```
1 a = [1, 2, 3, 4, 5, 2, 3]
2 
3 def fun1(a):
4     a = list(set(a))
5     print(a)
6 
7 fun1(a)
```

方法二：

```
1 a = [1, 2, 3, 4, 5, 2, 3]
2 
3 def fun1(a):
4     b = {}
5     b = b.fromkeys(a)
6     c = list(b.keys())
7     print(c)
8 
9 c = fun1(a)
```




### 理解django中的QuerySet两大特性:惰性执行和缓存

1.什么时候返回QuerySet对象?

Django的ORM中存在查询集的概念。

查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。

当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）：

all()：返回所有数据。
filter()：返回满足条件的数据。
exclude()：返回满足条件之外的数据。
order_by()：对结果进行排序。
 2.查询集特性:

一:惰性执行

```python
books = BookInfo.objects.all() # 此时,数据库并不会进行实际查询

# 只有当真正使用时,如遍历的时候,才会真正去数据库进行查询

for b in books:

    print(b)

```

二:缓存

```python
# 进行数据库实际查询遍历,保存结果到bs,会进行数据库实际交互

bs = [b.id for b in BookInfo.objects.all()]

# 再次调用缓存结果bs,不再进行数据库查询,而是使用缓存结果

print(bs) # [1, 2, 3, 4, 5, 6, 7, 10]

```



##### 
